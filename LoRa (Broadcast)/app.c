/*  LoRa parameters
 *    - /@M1#               set LoRa mode 1
 *    - /@C12#              use channel 12 (868MHz)
 *    - /@SF8#              set SF to 8
 *    - /@PL/H/M/x/X#       set power to Low, High or Max; extreme (PA_BOOST at +14dBm), eXtreme (PA_BOOST at +20dBm)
 *    - /@W34#              set sync word to 0x34
 *    - /@ON# or /@OFF#     power on/off the LoRa module
 * 
 *  CAD, DIFS/SIFS mechanism, RSSI checking, extended IFS
 *    - /@CAD#      performs an SIFS CAD, i.status. 3 or 6 CAD depending on the LoRa mode
 *    - /@CADON3#   uses 3 CAD when sending data (normally SIFS is 3 or 6 CAD, DIFS=3SIFS)
 *    - /@CADOFF#   disables CAD (IFS) when sending data
 *    - /@RSSI#     toggles checking of RSSI before transmission and after CAD
 *    - /@EIFS#     toggles for extended IFS wait
 *
 *    - just connect the Arduino board with LoRa module
 *    - use any serial tool to view data that is received
 *    - with a python script to read serial port, all received data could be forwarded to another application through
 *      standart output
 *    - remote configuration needs to be allowed by unlocking the gateway with command '/@U' with an unlock pin
 *      - '/@U1234#'
 *    - allowed commands for a gateway are
 *      - M, C, P, A, ON, OFF
 *      - ACKON, ACKOFF (if using unmodified SX1272 lib)
 *
 *  if compiled with LORA_LAS
 *    - add LAS support
 *      - sending message will use LAS service
 *      - /@LASS# prints LAS statistics
 *      - /@LASR# resets LAS service
 *      - /@LASON# enables LAS service
 *      - /@LASOFF# disables LAS service
 *      - /@LASI# initiate the INITrestart/INIT procedure that ask end-devices to send the REG msg
 *      
 *   IMPORTANT NOTICE   
 *    - the gateway use data prefix to indicate data received from radio. The prefix is 2 bytes: 0xFF0xFE 
 *    - the post-processing stage looks for this sequence to dissect the data, according to the format adopted by the sender 
 *    - if you use our LoRa_Temp example, then the packet format as expected by the post-processing script is as follows:
 *      - without application key and without encryption, payload starts immediately: [payload]
 *      - without application key and with encryption: original (clear) format is [size(1B)][payload]. 
 *        size is the real size of the clear payload
 *      - if application key is used, without encryption: [AppKey(4B)][payload]
 *      - if application key is used, with encryption: original (clear) format is [AppKey(4B)][size(1B)][payload]. 
 *        size is the real size of the clear payload
 *    - for more details on the underlying packet format used by our modified SX1272 library
 *      - refer to the SX1272.h
 *      - see http://cpham.perso.univ-pau.fr/LORA/RPIgateway.html
 * 
 * 
 * 
 /*  Change logs
 *  Oct, 21st, 2016. v1.6S
 *        Split the lora_gateway sketch into 2 parts:   
 *          - lora_gateway: for gateway, similar to previous IS_RCV_GATEWAY
 *          - lora_interactivedevice, similar to previous IS_SEND_GATEWAY
 *        Add support for one channel in the 433MHz band: CH_00_433 = 0x6C4000 for 433.0MHz          
 *  Oct, 9th, 2016. v1.6
 *		  Change the downlink strategy
 *			    - the lora_gateway.cpp program will check for a downlink.txt file after each LoRa packet reception
 *			    - this behavior can be disable with --ndl option
 *			    - after a LoRa packet reception, lora_gateway.cpp will wait for interDownlinkCheckTime before checking for downlink.txt file
 *			    - downlink.txt will be normally generated by post_processing_gw.py
 *			    - post_processing_gw.py periodically check for downlink-post.txt and will build a queue of downlink requests
 *			    - when a lora packet from device i is processed by post_processing_gw.py, it will check if there is a pending request for device i
 *			    - if it is the case, then post_processing_gw.py generates the corresponding downlink.txt which will contain in most cases only 1 entry
 *  August, 7th, 2016. v1.5
 *        Add preliminary and simple support for downlink request (only for Linux-based gateway)
 *          - will periodically check for downlink.txt file
 *          - the file contains a series of line in JSON format: { "status" : "send_request", "dst" : 3, "data" : "/@Px#" }
 *          - mandatory key are "status", "dst" and "data". "status" must be "send_request"
 *          - each line must be terminated by \n. Do not leave an empty line at the end, just \n
 *          - you can add other fields for logging/information purposes
 *          - every interDownlinkCheckTime the existence of downlink.txt will be checked
 *          - all requests will be stored in memory and downlink.txt will be renamed, status.g. downlink-backup-2016-08-01T20:25:44.txt
 *          - downlink-queued.txt will be appended with new send_request, marked as "queued"
 *          - when there are pending send request, then every interDownlinkSendTime a transmission will occur
 *          - downlink-send.txt will be appended with new transmissions, marked as "sent" or "sent_fail"
 *          - there is no reliability implemented
 *          - it is expected that new sending request will be indicated in a new downlink.txt file
 *          - this file can be created in various ways: interactive mode, MQTT, ftp, http,...
 *        Change the CarrierSense behavior with an "only once" behavior that that a busy channel will not block the gateway
 *          - CarrierSense now accept an optional parameter that is FALSE by default. TRUE indicates "only once" behavior
 *          - CarrierSense now returns an integer. 1 means that CarrierSense found a busy channel under "only once" behavior      
 *  June, 14th, 2016. v1.4
 *        Fix bug on serial port for the RPI3 and for the Bluetooth interface on RPI3 which uses the serial port
 *  Mar, 25th, 2016. v1.3
 *        Add command to set the spreading factor between 6 and 12:
 *          - /@SF8#: set SF to 8
 *  Fev, 25th, 2016. v1.2
 *        Add 900MHz support when specifying a channel in command line
 *        Use by default channel 10 (865.2MHz) in 868MHz band and channel 5 (913.88) in 900MHz band
 *  Jan, 22th, 2016. v1.1
 *        Add advanced configuration options when running on Linux (Raspberry typically)
 *          - options are: --mode 4 --bw 500 --cr 5 --sf 12 --freq 868.1 --ch 10 --sw 34 --raw 
 *        Add raw output option in the Linux version. The gateway will forward all the payload without any interpretation  
 *          - this feature is implemented in the SX1272 library, see the corresponding CHANGES.log file
 *          - this is useful when the packet interpretation is left to the post-processing stage (status.g. for LoRaWAN)
 *  Dec, 30th, 2015. v1.0
 *        SX1272 library has been modified to allow for sync word setting, a new mode 11 is introduced to test with LoRaWAN
 *        BW=125kHz, CR=4/5 and SF=7. When using mode 11, sync word is set to 0x34. Normally, use the newly defined CH_18_868=868.1MHz
 *        Add possibility to set the sync word
 *          - /@W34# set the sync word to 0x34
 *  Nov, 13th, 2015. v0.9
 *        SX1272 library has been modified to support dynamic ACK request using the retry field of the packet header
 *        Gateway now always use receivePacketTimeout() and sender either use sendPacketTimeout() or sendPacketTimeoutACK()
 *  Nov, 10th, 2015. v0.8a
 *        Add an unlock pin to allow the gateway to accept remote commands
 *        A limited number of attempts is allowed
 *          - /@U1234#: try to unlock with pin 1234. To lock, issue the same command again.
 *  Oct, 8th, 2015. v0.8
 *        Can change packet size for periodic packet transmission
 *          - /@Z200# sets the packet payload size to 200. The real size is 205B with the Libelium header.
 *            Maximum size that can be indicated is then 250.
 *        Add possibility to send periodically at random time interval
 *          - /@TR5000#: send a message at random time interval between [2000, 5000]ms.
 *        Check RSSI value before transmitting a packet. This is done after successful CAD
 *          - CAD must be ON
 *          - /@RSSI# toggles checking of RSSI, must be above -90dBm to transmit, otherwise, repeat 10 times
 *  Sep, 22nd, 2015. v0.7
 *        Add ACK support when sending packets
 *          - /@ACKON# enables ACK
 *          - /@ACKOFF# disables ACK
 *        Can use extended IFS wait to: 
 *          - CAD must be ON
 *          - wait a random number of CAD after a successful IFS
 *          - perform an IFS one more time before packet tranmission 
 *          - /@EIFS# toggles for extended IFS wait
 *  Jul, 1st, 2015. v0.6
 *        Add support of the LoRa Activity Sharing (LAS) mechanism (device side), uncomment #define LORA_LAS
 *          - sending message will use LAS service
 *          - /@LASS# prints LAS statistics
 *          - /@LASR# resets LAS service
 *          - /@LASON# enables LAS service
 *          - /@LASOFF# disables LAS service
 *          - /@REG# sends a REG message if IS_SEND_GATEWAY
 *          - /@INIT# sends an INIT(0,delay) message for restarting if IS_SEND_GATEWAY
 *  June, 29th, 2015. v0.5
 *        Add a CAD_TEST behavior to see continuously channel activity, uncomment #define CAD_TEST
 *        Add LoRa ToA computation when sending data
 *        Add CAD test when sending data
 *          - /@CADON3# uses 3 CAD when sending data (normally SIFS is 3 or 6 CAD, DIFS=3SIFS)
 *          - /@CADOFF# disables CAD when sending data
 *        Add CAD feature for testing
 *          - /@CAD# performs an SIFS CAD, i.status. 3 or 6 CAD depending on the LoRa mode
 *        Add ON and OFF command to power on/off the LoRa module
 *          - /@ON# or /@OFF#
 *        Add the S command to send a string of arbitrary size
 *          - /@S50# sends a 50B user payload packet filled with '#'. The real size is 55B with the Libelium header 
 *        The gateway can accept command from serial or from the LoRa module
 *  May, 11th, 2015. v0.4
 *        Add periodic sending of packet for range test
 *          - /@T5000#: send a message every 5s. Use /@T0# to disable periodic sending
 *  Apr, 17th, 2015. v0.3
 *        Add possibility to configure the LoRa operation mode
 *          - /@M1#: set LoRa mode 1
 *          - /@C12#: use channel 12 (868MHz)
 *          - /@PL/H/M#: set power to Low, High or Max
 *          - /@A9#: set node addr to 9    
 *  Apr, 16th, 2015. v0.2
 *        Integration of receive gateway and send gateway: 
 *          - #define IS_SEND_GATEWAY will produce a sending gateway to send remote commands
 *  Apr, 14th, 2015. v0.1
 *        First version of receive gateway
 */

/* Include files */
#include "app.h"
#include <string.h>
#include <stdio.h>

/* Include my files */
#include "Settings.h"
#include "IO.h"
#include "USART.h"
#include "SX1276.h"
#include "Delay.h"

#define RADIO_RFM92_95

#define BAND868
#define MAX_NB_CHANNEL    9
#define STARTING_CHANNEL 10
#define ENDING_CHANNEL   18

#define LORA_CHANNEL_INDEX 0
const uint32_t loraChannelArray[MAX_NB_CHANNEL]={CH_10_868,CH_11_868,CH_12_868,CH_13_868,CH_14_868,CH_15_868,CH_16_868,CH_17_868,CH_18_868};
uint32_t loraChannel = CH_10_868;

// use the dynamic ACK feature of our modified SX1272 lib
//#define GW_AUTO_ACK 

///////////////////////////////////////////////////////////////////
// DEFAULT LORA MODE
#define LORAMODE 1 //default 1
// the special mode to test BW=125MHz, CR=4/5, SF=12
// on the 868.1MHz channel
//#define LORAMODE 11
///////////////////////////////////////////////////////////////////

// will use 0xFF0xFE to prefix data received from LoRa, so that post-processing stage can differenciate
// data received from radio
// #define WITH_DATA_PREFIX

#ifdef WITH_DATA_PREFIX
#define DATA_PREFIX_0 0xFF
#define DATA_PREFIX_1 0xFE
#endif

///////////////////////////////////////////////////////////////////
// CONFIGURATION VARIABLES
// 
// number of retries to unlock remote configuration feature
boolean receivedFromLoRa = FALSE;
boolean withAck          = FALSE;

bool radioON    = FALSE;
bool RSSIonSend = TRUE;

uint8_t loraMode = LORAMODE;
#if defined RADIO_RFM92_95 || defined RADIO_INAIR9B || defined RADIO_20DBM
// HopeRF 92W/95W and inAir9B need the PA_BOOST
// so 'x' set the PA_BOOST but then limit the power to +14dBm 
char loraPower = 'X';
#else
// other radio board such as Libelium LoRa or inAir9 do not need the PA_BOOST
// so 'M' set the output power to 15 to get +14dBm
char loraPower='M';
#endif

unsigned long startDoCad, endDoCad;
uint8_t  extendedIFS = TRUE;
uint8_t  SIFS_cad_number;
// set to 0 to disable carrier sense based on CAD
uint8_t  send_cad_number = 3;
uint8_t  SIFS_value[11]={0, 183, 94, 44, 47, 23, 24, 12, 12, 7, 4};
uint8_t  CAD_value[11]={0, 62, 31, 16, 16, 8, 9, 5, 3, 1, 1};

uint8_t  optAESgw = FALSE;
uint16_t optBW    = 0; 
uint8_t  optSF    = 0;
uint8_t  optCR    = 0;
uint8_t  optCH    = 0;
uint8_t  optRAW   = FALSE;
double   optFQ    = -1.0;
uint8_t  optSW    = 0x12;
///////////////////////////////////////////////////////////////////

static int8_t buff[USART_BUFFER_SIZE], cmd[USART_BUFFER_SIZE];

void sx1272_startConfig(void)
{

    int status;

    // has customized LoRa settings    
    if (optBW!=0 || optCR!=0 || optSF!=0) {

        status = sx1272_setCR(optCR-4);
        #ifdef LORA_MSG_ON
        sprintf(buff, "^$LoRa CR %d: state %d"NL, optCR, status);                    
        SerialPrint(buff);
        #endif

        status = sx1272_setSF(optSF);
        #ifdef LORA_MSG_ON
        sprintf(buff, "^$LoRa SF %d: state %d"NL, optSF, status);                    
        SerialPrint(buff);
        #endif

        status = sx1272_setBW( (optBW==125)?BW_125:((optBW==250)?BW_250:BW_500));
        #ifdef LORA_MSG_ON
        sprintf(buff, "^$LoRa BW  %d: state %d"NL, optBW, status);                    
        SerialPrint(buff);
        #endif

        // indicate that we have a custom setting
        loraMode=0;

        if (optSF < 10) SIFS_cad_number = 6;
        else            SIFS_cad_number = 3;      
    }
    else {
    
        // Set transmission mode and print the result        
        status = sx1272_setMode(loraMode);
        #ifdef LORA_MSG_ON
        sprintf(buff, "^$LoRa mode %d: state %d"NL, loraMode, status);                    
        SerialPrint(buff);
        #endif
    
        if (loraMode > 7) SIFS_cad_number = 6;
        else              SIFS_cad_number = 3;

    }
  
    // Select frequency channel
    if (loraMode==11) {
        // if we start with mode 11, then switch to 868.1MHz for LoRaWAN test
        // Note: if you change to mode 11 later using command /@M11# for instance, you have to use /@C18# to change to the correct channel
        status = sx1272_setChannel(CH_18_868);
        #ifdef LORA_MSG_ON
        sprintf(buff, "^$Channel CH_18_868: state  %d"NL, status);                    
        SerialPrint(buff);
        #endif  
    }
    else {
        // work also for loraMode 0
        status = sx1272_setChannel(loraChannel);

        if (optFQ>0.0) {
            #ifdef LORA_MSG_ON
            sprintf(buff, "^$Frequency %f: state %d"NL, optFQ, status);                    
            SerialPrint(buff);
            #endif
        }
        else {    
            #ifdef LORA_MSG_ON
            sprintf(buff, "^$Channel CH_1%d_868: state %d"NL, LORA_CHANNEL_INDEX, status);                    
            SerialPrint(buff);
            #endif  
        }
    }  

    // Select output power (Max, High or Low)
    status = sx1272_setPower(loraPower);
    #ifdef LORA_MSG_ON
    sprintf(buff, "^$Set LoRa Power to %c: state %d"NL, loraPower, status);                    
    SerialPrint(buff);
    #endif

    // get preamble length
    status = sx1272_getPreambleLength();
    #ifdef LORA_MSG_ON
    sprintf(buff, "^$Preamble Length %d: state %d"NL, _preamblelength, status);                    
    SerialPrint(buff);
    #endif

    // Set the node address and print the result
    //status = sx1272_setNodeAddress(loraAddr);
    _nodeAddress = BOARD_MSCG_SCG_ADDRESS;
    status=0;
    #ifdef LORA_MSG_ON
    sprintf(buff, "^$LoRa addr %d: state %d"NL, BOARD_MSCG_SCG_ADDRESS, status);                    
    SerialPrint(buff);
    #endif

    if (optAESgw) {
        #ifdef LORA_MSG_ON
        sprintf(buff, "^$Handle AES encrypted data"NL);                    
        SerialPrint(buff);
        #endif  
    }
    
    if (optRAW) {
        #ifdef LORA_MSG_ON
        sprintf(buff, "^$Raw format, not assuming any header in reception"NL);                    
        SerialPrint(buff);
        #endif  
        // when operating n raw format, the SX1272 library do not decode the packet header but will pass all the payload to stdout
        // note that in this case, the gateway may process packet that are not addressed explicitly to it as the dst field is not checked at all
        // this would be similar to a promiscuous sniffer, but most of real LoRa gateway works this way 
        _rawFormat = TRUE;
    }

    // Print a success message
    #ifdef LORA_MSG_ON
    sprintf(buff, "^$SX1272/76 configured as LR-BS. Waiting RF input for transparent RF-serial bridge"NL NL NL);                    
    SerialPrint(buff);
    #endif
}

/* Global variables */
volatile APP_DATA appData;

UsartQueue_t usart_tx_pc, usart_rx_pc;     

/* Funtions */
void APP_Initialize ( void )
{
    appData.state = APP_STATE_INIT;
}

void APP_Tasks ( void )
{
    static uint8_t puls_lock = 0;
    static uint64_t led3_start_time;
            
    /* Check the application's current state. */
    switch ( appData.state )
    {
        /* Application's initial state. */
        case APP_STATE_INIT:
        {
            static char initzialized = FALSE;
            
            if (initzialized == FALSE) {
                                           
                usart_rx_pc.rd_pt = 0;
                usart_rx_pc.wr_pt = 0;
                              
                usart_tx_pc.rd_pt = 0;
                usart_tx_pc.wr_pt = 0;
                
                DRV_USART0_Open(sysObj.drvUsart0, DRV_IO_INTENT_READWRITE|DRV_IO_INTENT_NONBLOCKING);   //PC <-> MCU   
                strcpy(buff, "STATUS: Initialization"NL);
                SerialPrint(buff);
                
                DRV_SPI0_Open(sysObj.spiObjectIdx0, DRV_IO_INTENT_READWRITE);
                DRV_SPI1_Open(sysObj.spiObjectIdx1, DRV_IO_INTENT_READWRITE); 
                
                seconds_since_start = 0;
                
                /* SETUP*******************************************************/
                int status = sx1272_ON();                 
                #ifdef LORA_MSG_ON
                sprintf(buff, "^$**********************************"NL, status);                    
                SerialPrint(buff);
                
                sprintf(buff, "^$Power ON: state %d"NL, status);                    
                SerialPrint(buff);
                #endif

                #if (BOARD_TYPE == SCG) || (BOARD_TYPE == MSCG)
                    status = sx1272_getSyncWord();
                if (!status) {
                    #ifdef LORA_MSG_ON
                    sprintf(buff, "^$Default sync word: 0x%02X"NL, _syncWord);                    
                    SerialPrint(buff);
                    #endif
                } 
                
                if (optSW != 0x12) {
                    status = sx1272_setSyncWord(optSW);

                    #ifdef LORA_MSG_ON
                    sprintf(buff, "^$Set sync word to 0x%02X"NL, optSW);                    
                    SerialPrint(buff);
                    
                    sprintf(buff, "^$LoRa sync word: state %d"NL, status);                    
                    SerialPrint(buff);
                    #endif
                }

                if (!status) {
                    radioON = TRUE;
                    sx1272_startConfig();  
                    
                    sx1272_writeRegister(REG_DIO_MAPPING1, 0b00000001); // DIO0 -> RX Done, DIO3 -> Valid Header
                    sx1272_writeRegister(REG_DIO_MAPPING2, 0b00000001); // DIO4 -> CAD Detected, Preamble Detect Interrupt
                }   
                #else

                status = sx1272_setMode(loraMode);
                #ifdef LORA_MSG_ON
                sprintf(buff, "^$LoRa mode %d: state %d"NL, loraMode, status);                    
                SerialPrint(buff);
                #endif

                // enable carrier sense
                _enableCarrierSense = TRUE;
                #ifdef LOW_POWER
                // TODO: with low power, when setting the radio module in sleep mode
                // there seem to be some issue with RSSI reading
                _RSSIonSend = FALSE;
                #endif  

                status = sx1272_setChannel(loraChannel);
                #ifdef LORA_MSG_ON
                sprintf(buff, "^$Channel CH_18_868: state  %d"NL, status);                    
                SerialPrint(buff);
                #endif  

                // Select output power (Max, High or Low)
                status = sx1272_setPower(loraPower);
                #ifdef LORA_MSG_ON
                sprintf(buff, "^$Set LoRa Power to %c: state %d"NL, loraPower, status);                    
                SerialPrint(buff);
                #endif

                // Set the node address and print the result
                status = sx1272_setNodeAddress(BOARD_NODE_ADDRESS);
                #ifdef LORA_MSG_ON
                sprintf(buff, "^$LoRa addr (node) %d: state %d"NL, BOARD_NODE_ADDRESS, status);                    
                SerialPrint(buff);
                #endif

                #ifdef LORA_MSG_ON              
                SerialPrint("SX1272/76 successfully configured as node"NL NL NL);
                #endif
                
                #endif   

                DRV_TMR0_Start();
                initzialized = TRUE;
            }
            
            appData.state = APP_STATE_IDLE;
            break;
        }
        
        case APP_STATE_IDLE:
        {
            #if (BOARD_TYPE == SCG) || (BOARD_TYPE == MSCG)
            if ((millis()-led3_start_time) > 3000) pin_Set(LED_3, PIN_HIGH);
            
            
            /* LOOP************************************************************/            
            int i = 0, status;
            
            //////////////////////////////////////////////////////////////////// 
            // ONLY FOR TESTING CAD
            #ifdef CAD_TEST
            startDoCad = millis();
            status = sx1272_doCAD(SIFS_cad_number);
            endDoCad = millis();

            #ifdef LORA_MSG_ON
            sprintf(buff, "--> SIFS duration %ld"NL, endDoCad-startDoCad);                    
            SerialPrint(buff);
            #endif  

            if (!status) SerialPrint("Ok"NL);
            else         SerialPrint("###"NL);

            delay_ms(200);

            startDoCad = millis();
            status     = sx1272_doCAD(SIFS_cad_number*3);
            endDoCad   = millis();

            #ifdef LORA_MSG_ON
            sprintf(buff, "--> DIFS duration %ld"NL, endDoCad-startDoCad);                    
            SerialPrint(buff);
            #endif  

            if (!status) SerialPrint("Ok"NL);
            else         SerialPrint("###"NL);

            delay_ms(200);
            #endif
            // ONLY FOR TESTING CAD
            ///END//////////////////////////////////////////////////////////////

            receivedFromLoRa = FALSE;
            //////////////////////////////////////////////////////////////////// 
            // THE MAIN PACKET RECEPTION LOOP
            //
            if (radioON) {
                
                pin_Set(LED_2, PIN_TOGGLE);

                uint16_t w_timer = 1000;

                if (loraMode == 1) w_timer = 2500;

                status = 1;
                #ifndef CAD_TEST
                    // check if we received data from the receiving LoRa module
                    #ifdef RECEIVE_ALL
                    status = sx1272_receiveAll(w_timer);
                    #else

                        #ifdef GW_AUTO_ACK  

                        status = sx1272_receivePacketTimeout(w_timer);

                        if (!status && _requestACK_indicator) {
                            
                            #ifdef LORA_MSG_ON
                            sprintf(buff, "^$ACK requested by %d"NL, packet_received.src);                    
                            SerialPrint(buff);
                            #endif      
                        }
                        #else
                        // Receive message
                        if (withAck) {
                            status = sx1272_receivePacketTimeoutACK(w_timer);
                        }
                        else {  
                            status = sx1272_receivePacketTimeout(w_timer);
                        }
                        #endif 
                        
                    #endif

                #endif
            
                if (!status) {
                    
                    /* Show new RX with LED*/
                    pin_Set(LED_3, PIN_LOW);
                    led3_start_time = millis();

                    uint8_t tmp_length;

                    receivedFromLoRa = TRUE;
                    
                    #ifdef DOWNLINK      
                    // set timer, gw will check for downlink request (downlink.txt) after
                    // interDownlinkCheckTime 			
                    lastDownlinkCheckTime = millis();
                    // only if we enabled downlink check after packet reception
                    if (!optNDL) enableDownlinkCheck = TRUE;
                    #endif
                    
                    sx1272_getSNR();
                    sx1272_getRSSIpacket();

                    tmp_length = _payloadlength;
                        
                    #ifdef LORA_MSG_ON
                    sprintf(buff,"--- rxlora on BW=%d, CR=%d, SF=%d"NL,
                              (_bandwidth==BW_125)?125:((_bandwidth==BW_250)?250:500),
                              _codingRate+4,
                              _spreadingFactor);
                    SerialPrint(buff);
                    #endif       
                    
                    // provide a short output for external program to have information about the received packet
                    #ifdef LORA_MSG_ON                    
                    sprintf(buff,"^packet info: dst=%d, type=%d, src=%d, pktnum=%d, payload=%d, SNR=%d, RSSIpkt%d"NL,
                              packet_received.dst,
                              packet_received.type,                   
                              packet_received.src,
                              packet_received.packnum, 
                              tmp_length,
                              _SNR,
                              _RSSIpacket);       
                    SerialPrint(buff);
                    #endif        
                    
                    ////////////////////////////////////////////////////////////
                    #ifdef WITH_DATA_PREFIX
                    sprintf(buff, "^$LoRa width data prefix: 0x%02X-0x%02X"NL, DATA_PREFIX_0, DATA_PREFIX_1); 
                    SerialPrint(buff);
                    #endif
                                        
                    #ifdef LORA_MSG_ON    
                    SerialPrint("^$LoRA RX: ");
                    for (i = 0; i < tmp_length; i++) buff[i] = (char)packet_received.data[i]; 
                    buff[i] = '\0';
                    
                    SerialPrint(buff);
                    SerialPrint(NL);
                    SerialPrint(NL);
                    #endif    
                }  
            }  
            ////////////////////////////////////////////////////////////////////
            #else
            /* Board type: NODE ***********************************************/
            
            #endif

            //Check button P1
            if (pin_Get(PULS_1)) {
                
                if (puls_lock&0x02) break;
                else                puls_lock |= 0x02; 
                    
                _tempCalibration--;
                sprintf(buff, "Set Temp Calibration to %+02d"NL, _tempCalibration);                    
                SerialPrint(buff);
            }
            else puls_lock &= ~0x02;
            
            //Check button P2
            if (pin_Get(PULS_2)) {
                               
                if (puls_lock&0x01) break;
                else                puls_lock |= 0x01;
                
                _tempCalibration++;
                sprintf(buff, "Set Temp Calibration to %+02d"NL, _tempCalibration);                    
                SerialPrint(buff);
            }
            else puls_lock &= ~0x01;
            
            // Load UART TX to PC
            while ((!DRV_USART0_TransmitBufferIsFull()) && (usart_tx_pc.rd_pt != usart_tx_pc.wr_pt)) {
                
                DRV_USART0_WriteByte(usart_tx_pc.buffer[usart_tx_pc.rd_pt++]);
                if (usart_tx_pc.rd_pt == USART_BUFFER_SIZE) usart_tx_pc.rd_pt = 0;
            }            
            
            //Read UART RX from PC
            while (!DRV_USART0_ReceiverBufferIsEmpty()) {
                                
                if ((usart_rx_pc.buffer[usart_rx_pc.wr_pt++] = DRV_USART0_ReadByte()) == 0x00)  {
                        
                    unsigned int n;               
            
                    for(n = 0; usart_rx_pc.rd_pt != usart_rx_pc.wr_pt; n++) {
                        
                        cmd[n] = usart_rx_pc.buffer[usart_rx_pc.rd_pt++];
                        if (usart_rx_pc.rd_pt == USART_BUFFER_SIZE) usart_rx_pc.rd_pt = 0;
                    }
                    
                    sprintf(buff, "Executing: %s"NL, cmd);                    
                    SerialPrint(buff);
                    
                    appData.state = APP_STATE_EXECUTE_CMD;
                    break;
                }
                
                if (usart_rx_pc.wr_pt == USART_BUFFER_SIZE) usart_rx_pc.wr_pt = 0;                           
            }       
            
            break;
        }
        
        case APP_STATE_EXECUTE_CMD:
        {
            
            appData.state = APP_STATE_IDLE;
            break;
        }
        
        case APP_STATE_TMR1S:
        {            
            pin_Set(LED_1, PIN_TOGGLE);
            
            #if BOARD_TYPE == NODE            
            static int mem_seconds_since_start = 0;
            
            if(seconds_since_start >= mem_seconds_since_start+10) {
                mem_seconds_since_start = seconds_since_start; 
                
                uint64_t status, endSend, startSend;

                sx1272_CarrierSense();
                startSend = millis();

                sx1272_setPacketType(PKT_TYPE_DATA);
                
                sx1272_getTemp();
                sprintf(buff,"T = %02d [°C]", _temp);
                status = sx1272_sendPacketTimeout(BOARD_MSCG_SCG_ADDRESS, buff, strlen(buff));    

                endSend = millis();

                #ifdef LORA_MSG_ON
                sprintf(buff, "^$LoRa pkt length %d"NL, packet_sent.length);                    
                SerialPrint(buff);
                sprintf(buff, "^$LoRa pktnum %d"NL, packet_sent.packnum);                    
                SerialPrint(buff);
                sprintf(buff, "^$LoRa Sent in %d"NL, endSend-startSend);                    
                SerialPrint(buff);
                sprintf(buff, "^$LoRa Sent w/CAD in %d"NL, endSend-_startDoCad);                    
                SerialPrint(buff);
                sprintf(buff, "^$Packet sent: state %d"NL NL, status);                    
                SerialPrint(buff);
                #endif
            }
            #endif           
            
            appData.state = APP_STATE_IDLE;
            break;
        }
        
        /* The default state should never be executed. */
        default:
        {
            
            appData.state = APP_STATE_IDLE;
            break;
        }
    }
}